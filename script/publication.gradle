def signingKeyId = 'signing.keyId'
def signingPassword = 'signing.password'
def signingSecretKeyRingFile = 'signing.secretKeyRingFile'
def ossrhUsername = 'ossrh.username'
def ossrhPassword = 'ossrh.password'
def isCheckPass = true

def logWarn(String msg){
    project.logger.log(LogLevel.WARN, "MavenPublishScript: ${msg}")
}

def logError(String msg){
    project.logger.log(LogLevel.ERROR, "MavenPublishScript: ${msg}")
}

def isAndroidLibrary(){
    return project.plugins.hasPlugin('com.android.library')
}

def isJavaLibrary(){
    return project.plugins.hasPlugin('java-library') || project.plugins.hasPlugin('java')
}

def isSupportPublish(){
    return isAndroidLibrary() || isJavaLibrary()
}

def readProperty(String key){
    String value = project.hasProperty(key) ? project[key] : ''
    return new String(value.getBytes('utf-8'), 'utf-8')
}

def containProperty(String key){
    return project.properties.containsKey(key)
}

def readBoolean(String key){
    return readProperty(key).toLowerCase() == 'true'
}

def loadLocalProperties(){
    File localPropsFile = project.rootProject.file('local.properties')
    if (localPropsFile.exists()) {
        Properties props = new Properties()
        props.load(new FileInputStream(localPropsFile))
        props.each {name, value ->
            ext[name] = value
        }
        return true
    } else {
        return false
    }
}

static def isEmpty(String string){
    return string == null || string.isEmpty()
}

def getSrcDirs(variant){
    def srcDirs
    try {
        srcDirs = variant.variantData.javaSources.collect {
            it.getDir()
        }
    } catch (Exception e) {
        e.printStackTrace()
    }
    if(srcDirs == null){
        try {
            srcDirs = variant.variantData.variantSources.sortedSourceProviders.collect {
                it.getJavaDirectories()
            }
        }catch (Exception e){
            e.printStackTrace()
        }
    }
    if(srcDirs == null){
        srcDirs = new HashSet<File>()
        srcDirs.addAll(project.android.sourceSets.main.java.srcDirs)
        srcDirs.addAll(project.android.sourceSets.release.java.srcDirs)
        if(!isEmpty(variant.flavorName)){
            srcDirs.addAll(project.android.sourceSets."${variant.flavorName}".java.srcDirs)
            srcDirs.addAll(project.android.sourceSets."${variant.flavorName}Release".java.srcDirs)
        }
    }
    return srcDirs
}

def getAGPVersion() {
    def version
    def agpDependency = project.rootProject.buildscript?.configurations?.findByName(ScriptHandler.CLASSPATH_CONFIGURATION)?.incoming?.dependencies?.find {
        it.group == "com.android.tools.build" && it.name == "gradle"
    }
    if(agpDependency != null){
        version = agpDependency.version
    }else {
        Class<?> gradleVersionClazz = project.plugins.getPlugin('com.android.library').class.getClassLoader().loadClass('com.android.builder.model.Version')
        version = (String) gradleVersionClazz.getDeclaredField('ANDROID_GRADLE_PLUGIN_VERSION').get(null)
    }
    return version
}

def static getRuntimeClasspath(variant){
    def runtimeClassPath
    try {
        runtimeClassPath = variant.variantData.variantDependency.runtimeClasspath
    } catch (Exception e) {
        e.printStackTrace()
        runtimeClassPath = variant.variantData.variantDependencies.runtimeClasspath
    }
    return runtimeClassPath
}

def resolveConfigurations(Collection<Configuration> configurations, Set<Configuration> resolvedConfigurations) {
    configurations.each {
        resolvedConfigurations.add(it)
        resolveConfigurations(it.extendsFrom, resolvedConfigurations)
    }
}

if(!isSupportPublish()){
    isCheckPass = false
    logError '目前只支持android工程和java工程的组件发布，暂不支持其他平台的组件发布'
}else if(isAndroidLibrary()){
    logWarn "项目是一个android工程"
    def version = getAGPVersion()
    if(version < '3.1.0'){
        isCheckPass = false
        logError '请升级android gradle pulgin版本, 不支持3.1.0以下的版本'
    }else{
        logWarn "AGP version = ${version}"
    }
}else if(isJavaLibrary()){
    logWarn '项目是一个java工程'
}

if(isCheckPass){
    if(!loadLocalProperties()){
        isCheckPass = false
        logError '项目根目录下local.properties文件不存在'
    }else{
        if(!containProperty(signingKeyId)
                || !containProperty(signingPassword)
                || !containProperty(signingSecretKeyRingFile)){
            isCheckPass = false
            logError 'gpg的签名信息不可以为空'
        }else{
            logWarn "signingKeyId = ${readProperty(signingKeyId)}"
            logWarn "signingPassword = ${readProperty(signingPassword)}"
            logWarn "signingSecretKeyRingFile = ${readProperty(signingSecretKeyRingFile)}"
        }
        if(!containProperty(ossrhUsername)
                || !containProperty(ossrhPassword)){
            isCheckPass = false
            logError 'ossrh的账号信息不可以为空'
        }else{
            logWarn "ossrhUsername = ${readProperty(ossrhUsername)}"
            logWarn "ossrhPassword = ${readProperty(ossrhPassword)}"
        }
    }
    if(!containProperty('GROUPID')
            || !containProperty('ARTIFACTID')
            || !containProperty('VERSION')){
        isCheckPass = false
        logError '组件的GAV不可以为空'
    }else{
        logWarn "GAV = ${GROUPID}:${ARTIFACTID}:${VERSION}"
    }
}

if(isCheckPass){
    apply plugin: 'maven-publish'
    apply plugin: 'signing'

    tasks.withType(Javadoc) {
        options.addStringOption('Xdoclint:none', '-quiet')
        options.addStringOption('encoding', 'utf-8')
        options.addStringOption('charSet', 'utf-8')
    }

    publishing.repositories{
        maven {
            def releasesRepoUrl = "https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/"
            def snapshotsRepoUrl = "https://s01.oss.sonatype.org/content/repositories/snapshots/"
            url = VERSION.endsWith('SNAPSHOT') ? snapshotsRepoUrl : releasesRepoUrl
            credentials {
                username readProperty(ossrhUsername)
                password readProperty(ossrhPassword)
            }
        }
    }

    publishing.publications{
        if(isAndroidLibrary()){
            android.libraryVariants.all{variant ->
                if('release' != variant.buildType.name){
                    return
                }
                def flavorName = variant.flavorName
                logWarn "variant = ${flavorName}Release"
                "${flavorName}Library"(MavenPublication) {
                    //组件GVA坐标
                    groupId GROUPID
                    artifactId readBoolean('APPENDFLAVORNAME') ? (ARTIFACTID + "-${flavorName}") : ARTIFACTID
                    version VERSION
                    //要发布的产物
                    def bundleAarTask = tasks.findByName("bundle${flavorName.capitalize()}Release")
                    if(bundleAarTask == null){
                        bundleAarTask = tasks.findByName("bundle${flavorName.capitalize()}ReleaseAar")
                    }
                    artifact bundleAarTask != null ? bundleAarTask : "${buildDir}/outputs/aar/${getName()}-release.aar"
                    def srcDirs = getSrcDirs(variant)
                    logWarn "srcDirs = ${srcDirs}"
                    def sourcesJarTask = tasks.create("${flavorName}${isEmpty(flavorName) ? 's' : 'S'}ourcesJar", Jar){
                        archiveClassifier = 'sources'
                        from srcDirs
                        exclude "**/R.java", "**/BuildConfig.java"
                    }
                    artifact sourcesJarTask
                    def javadocTask = tasks.create("${flavorName}${isEmpty(flavorName) ? 'j' : 'J'}avadoc", Javadoc){
                        failOnError false
                        source srcDirs
                        classpath += files(android.getBootClasspath().join(File.pathSeparator))
                        classpath += configurations.compile
                    }
                    def javadocJarTask = tasks.create("${flavorName}${isEmpty(flavorName) ? 'j' : 'J'}avadocJar", Jar){
                        archiveClassifier = 'javadoc'
                        dependsOn javadocTask
                        from javadocTask.destinationDir
                    }
                    artifact javadocJarTask
                    //要生成的pom文件
                    pom {
                        packaging = 'aar'
                        //组件的基本信息
                        name = readProperty('ARTIFACTID')
                        description = readProperty('DESCRIPTION')
                        url = readProperty('URL')
                        //licenses文件
                        licenses {
                            license {
                                name = readProperty('LICENSENAME')
                                url = readProperty('LICENSEURL')
                            }
                        }
                        //开发者信息
                        developers {
                            developer {
                                name = readProperty('DEVELOPERNAME')
                                email = readProperty('DEVELOPEREMAIL')
                            }
                        }
                        //版本控制仓库地址
                        scm {
                            url = readProperty('SCMURL')
                            connection = "scm:${readProperty('SCMCONNECTION')}"
                            developerConnection = "scm:${readProperty('SCMDEVELOPERCONNECTION')}"
                        }
//                        properties = [
//                            'project.build.sourceEncoding':'UTF-8',
//                            'project.reporting.outputEncoding':'UTF-8',
//                            'maven.compiler.encoding':'UTF-8'
//                        ]
                        //生成组件的依赖关系
                        withXml {
                            def dependenciesNode = asNode().appendNode('dependencies')
                            def runtimeClasspath = getRuntimeClasspath(variant)
                            def resolvedDependencies = [:]
                            //获取组件解析后的直接依赖
                            runtimeClasspath.resolvedConfiguration.firstLevelModuleDependencies.each{resolvedDependency ->
                                def group = resolvedDependency.moduleGroup
                                def name = resolvedDependency.moduleName
                                def version = resolvedDependency.moduleVersion
                                logWarn "resolvedDependency = ${group}:${name}:${version}"
                                if(version != 'unspecified'){
                                    resolvedDependencies["${group}:${name}"] = version
                                }
                            }
                            def runtimeConfigurations = new HashSet<>()
                            resolveConfigurations([runtimeClasspath], runtimeConfigurations)
                            //把依赖写入pom文件
                            runtimeConfigurations.each{configuration ->
                                configuration.dependencies.each{dependency ->
                                    def group = dependency.group
                                    def name = dependency.name
                                    def version = dependency.version
                                    def configurationName = configuration.name.toLowerCase()
                                    logWarn "dependency = ${configurationName} ${group}:${name}:${version}"
                                    String key = "${group}:${name}"
                                    if(resolvedDependencies.containsKey(key)){
                                        def dependencyNode = dependenciesNode.appendNode('dependency')
                                        dependencyNode.appendNode('groupId', group)
                                        dependencyNode.appendNode('artifactId', name)
                                        dependencyNode.appendNode('version', resolvedDependencies[key])
                                        //避免重复写入依赖
                                        resolvedDependencies.remove(key)
                                        if(configurationName.indexOf("implementation") != -1
                                                || configurationName.indexOf("runtime") != -1
                                        ){
                                            dependencyNode.appendNode("scope", "runtime")
                                        } else {
                                            dependencyNode.appendNode("scope", "compile")
                                        }
                                        //写入依赖的exclude
                                        def excludeRules = new HashSet(configuration.excludeRules)
                                        excludeRules.addAll(dependency.excludeRules)
                                        if(configuration.transitive == false || dependency.transitive == false || excludeRules.size() > 0) {
                                            def exclusionsNode = dependencyNode.appendNode('exclusions')
                                            if (configuration.transitive == false || dependency.transitive == false) {
                                                def exclusionNode = exclusionsNode.appendNode('exclusion')
                                                exclusionNode.appendNode('groupId', '*')
                                                exclusionNode.appendNode('artifactId', '*')
                                            } else {
                                                for (def excludeRule: excludeRules) {
                                                    def exclusionNode = exclusionsNode.appendNode('exclusion')
                                                    exclusionNode.appendNode('groupId', excludeRule.group == null ? '*' : excludeRule.group)
                                                    exclusionNode.appendNode('artifactId', excludeRule.module == null ? '*' : excludeRule.module)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }else if(isJavaLibrary()){
            "Jar"(MavenPublication) {
                groupId GROUPID
                artifactId ARTIFACTID
                version VERSION
                def sourcesJarTask = tasks.create("sourcesJar", Jar){
                    archiveClassifier = 'sources'
                    from sourceSets.main.allSource
                }
                artifact sourcesJarTask
                def javadocJarTask = tasks.create("javadocJar", Jar){
                    archiveClassifier = 'javadoc'
                    dependsOn javadoc
                    from javadoc.destinationDir
                }
                artifact javadocJarTask
                from components.java
                pom {
                    packaging = 'jar'
                    name = readProperty('ARTIFACTID')
                    description = readProperty('DESCRIPTION')
                    url = readProperty('URL')
                    licenses {
                        license {
                            name = readProperty('LICENSENAME')
                            url = readProperty('LICENSEURL')
                        }
                    }
                    developers {
                        developer {
                            name = readProperty('DEVELOPERNAME')
                            email = readProperty('DEVELOPEREMAIL')
                        }
                    }
                    scm {
                        url = readProperty('SCMURL')
                        connection = readProperty('SCMCONNECTION')
                        developerConnection = readProperty('SCMDEVELOPERCONNECTION')
                    }
//                    properties = [
//                            'project.build.sourceEncoding':'UTF-8',
//                            'project.reporting.outputEncoding':'UTF-8',
//                            'maven.compiler.encoding':'UTF-8'
//                    ]
                }
            }
        }
    }

    signing {
        //对每个输出进行签名
        sign publishing.publications
    }
}
